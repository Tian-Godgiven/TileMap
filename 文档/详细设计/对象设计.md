

[toc]

# 对象

## 文件

（1）结构：应用程序所生成的文件类型为tilemap，其中的内容是json格式的代码。工程文件由tilemap标签标识，自定义磁贴或模板文件则是object标签进行标识，无论哪种都在file_head属性中标识着文件修改时间，用户代理字符串，最后一次打开本文件且支持加载的软件版本。

​	文件的数据属性以键值对的形式保存了其中的对象的各种属性与内容。工程文件中包含着该文件内的各个画布，画布内包含着其中的画布内元素，这些元素的Dom属性，CSS属性，data数据，prop属性等都以json键值对的格式保存在各自的标签属性中。自定义磁贴或模板文件也是同样的结构，只不过不包含画布标签。

读取指定的文件内容是应用程序的基本功能之一，但错误或不支持的文件的读取可能会给用户带来不必要的困扰。将一部分信息填装在工程文件的文件头中，有利于在读取文件时，验证基本的文件信息，提前避免错误的产生。也能够起到版本控制等功能。

（2）生成与读取：这些文件的生成过程为：首先制作各Dom对应的标签，将其属性保存为json字符串，存储到对象属性中，按包含关系排列这些标签，最后用文件标签将其包裹，通过Node.js的fs方法产生文件，保存在本地或上传至服务器。

读取则是生成的逆过程：首先判定文件标签的类型，然后按照对应的过程依次读取对象的属性，通过对应的生成函数产生Dom元素，再按照包含关系放置这些Dom元素，最终按文件标签类型决定是将其载入画布区或是加入磁贴集合区。

​	本软件产生的应用文件后缀均为.tilemap，作为后缀标志着文件的服务对象，也是文件读取过程中最先进行的筛查。JSON格式的引用文件在加载时十分高效，但也出现了内容冗杂，文件体积控制能力差，保密性不足等缺点，这是本软件进一步开发所需要优化的问题。

## 画布

一个画布可以与多个磁贴嵌套，并通过这些磁贴进入该画布。在通过某个磁贴进入画布时，会将这个进入行为保存到画布中的一个顺序栈中，在返回上一层画布时，顺序栈的栈顶进入行为出栈，并借此找到最近一次进入该画布的磁贴以及其所在的画布，然后再回到这个画布。以此实现符合正常思维逻辑的返回上一层画布的操作。

​	需要再次提及的是，本软件与大部分思维导图设计软件的不同之处在于我们提供了在单纯的思维结构设计的基础上，进一步拓充内容而不会影响整体机构的展示的功能。因此可预见的会产生一些结构复杂，内容充足的大型思维导图。在多层画布嵌套与上述体积的画布、画布内对象的跳转功能的影响下，为用户提供符合正常逻辑的跳转和返回逻辑能够大幅改善用户的使用体验。画布嵌套功能是本软件相较于其他同类型软件的特色，为其提供诸多优化和支持以使得用户能够更便利地对其进行使用，是本软件的核心目标之一。

## 画布内对象

画布内对象指磁贴、线条和组合体，这些对象有一些通用的功能。

（1）复制与粘贴：画布内对象的复制操作会在剪贴板中保存一个该对象的属性构成的json对象，在画布上粘贴时通过json对象生成一个新的对象，并重新分配id。因此当复制一个对象后，若该对象被删除，仍然可以进行粘贴。

对象的复制粘贴通常只在画布内有效，因此当向剪贴板中保存对象的json对象时，会将其保存在剪贴板的clipboard_object变量中，若粘贴的位置并非画布，则不会调用该变量。例外的是，在复制一个磁贴时，还会在剪贴板的文字内容中保存一个可被覆盖的data数据，其将指向这个磁贴。

当复制的对象是一个磁贴，粘贴的位置为磁贴内容时，会在该位置产生一个复制对象的磁贴的缩略图，点击这个缩略图将跳转到对应磁贴所在的位置。由于磁贴内容以字符串的形式保存在对应的磁贴的data属性中，当缩略图对应的磁贴被删除时，并不能同步删除这个data属性。因此，若缩略图对应的磁贴被删除，在点击这个缩略图时，将提示目标磁贴已被删除并让用户选择删除这个缩略图或是为其绑定另一个磁贴。

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml16932\wps46.png)

复制与粘贴的实现比较简单，将已有的对象赋予新的对象id并再生成一次即可。然而其核心函数jsonToObject()与objectToJson()的实现过程却十分冗长，作为软件最重要的对象生成和储存函数，为了将其适配种类繁多的不同情况的需求，必须对其进行完备的设置，根据不同的需求反复做出相应的调整，有时甚至会出现两种需求截然相反，相互矛盾的情况，为此必须舍弃掉基础功能以外的冗余代码，不断地做减法，已获得一个足够通用，足够健壮的基础功能。

（2）scale下的拖动与缩放：画布内对象的拖动借由jQuery-ui.js中的draggable()和resizable()模块实现，然而这两个模块在父元素通过scale属性修改显示大小时，无法令拖拽元素正确跟随鼠标移动，这是因为这两个模块在修改拖拽元素的位置属性时仅参考鼠标移动的像素大小，忽略了scale属性不修改真实位置和尺寸的特性。

因此，修改jQuery-ui.js中draggable()和resizable()模块，将scale属性放入鼠标移动轨迹的计算中，从而实现在scale影响下正确的拖动与缩放。

 

![img](file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml16932\wps47.png)

 

​	经过了数十年的积累和发展，当今的编程，尤其是前端编程界迎来了插件或各类中间件的富足时代。使用插件实现一些基础功能，避免“重复造轮子”的开发理念深入人心。本软件的顺利开发也离不开各类优秀的插件提供的功能支持。

​	然而我们也需要注意到，插件始终是由另一位开发者提供的工具，其开发理念，功能需求，实现方法都被隐藏在简洁明了的使用文档背后。插件的开发者也并非全能，无法顾及到每一位使用者的使用场景和需求。在本案例中，jquery-ui所提供的draggable()与resizable()模块就因为使用了常见的offset()属性测量dom元素的位置，从而与画布元素设置的scale属性发生冲突，导致了预料外的错误。在通过阅读插件代码，并修改关键内容后，解决了该问题。

​	丰富插件储备的确是现代开发者弥足珍贵的优势，但“非我代码，其心必异”，在使用插件的过程中，开发者也应当具备对其实现原理的基本认知，以免在后续开发的过程中出现需求冲突。此外，优秀的插件使用者也应当具备对插件的阅读和修改能力，按照自身需求更完善的可控制插件为己所用。

（3）调色盘：调色盘是一个通用的颜色修改组件，全局使用该组件修改各个对象的各种颜色。调色盘由色圆，调色条，颜色信息，色块组成。

其中色圆与调色条借助iro.js库提供的colorpicker模块实现。色块通过rgb颜色变化规律实现。列项按照从红色、绿色、蓝色再回到红色的顺序改变rgb值中红色，绿色，蓝色的分配比例。行项则以亮度减少为趋势，固定每一行rgb值的分配总额，最终实现均匀且合理的色块排列。

​		作为一项在诸多场合需要使用到的通用工具，对调色盘的功能覆盖面提出了考验。从一开始传入特殊的标识符，以在调色盘函数中实现特殊的功能，到后来通过回调函数获取调色盘的设置颜色，再到最后通过异步函数避免“回调地狱”的开发流程，体现的是一种完备性开发的思想的进步。想要提高一个工具的功能覆盖面，开发者需要做的并不是增加其可以实现的功能，而是将其功能接口以合理的形式暴露出来并链接到其他的功能。正确的完备性开发应当立足于可拓展性，想要在一开始就完成所有需求的实现是不现实的。

## 线条

在连线模式下选择不同的两个磁贴，即可在磁贴之间产生连接的线条。其本质上是一个svg的path对象。线条对象随着磁贴的移动不断更新属性，从而实现持续链接。

​		在同类型的思维导图设计软件中，使用svg图形作为软件的基础设计元素是十分常见的做法，相较于普通的dom元素，其优势也很明显，那就是不依赖于dom结构，可以随意绘制出各式各样的图形。从设计角度而言，svg图形占有绝对优势，然而从功能实现的角度而言，svg图形在事件响应上效率很低，需要额外设置对应的dom作为响应载体，会使得元素结构变得更加复杂，增大开发的工作量。

​		不过，对于本软件需要实现的线条对象而言，使用svg图形是更具效率的方法。使用dom结构实现可控的线条对象十分复杂，并且会涉及到旋转rotate这个在CSS中没能获得充足支持的属性，加之应用程序对线条对象的设置与响应需求十分简单，灵活地换用svg图形是更为合理的选择。

## 组合体

组合体的生成通过鼠标在画布内的框选套索，在选中一定范围内的磁贴后，形成临时组合体。临时组合体会在其失去聚焦时拆散，可以在组合体的修饰页面中选择将其组合在一起，从而形成固定的组合体。

​		组合体是本软件中最为重要的对象之一，是实现模板功能的基础对象。然而在开发过程中，组合体作为画布容器之内的容器，对开发的完备性提出了考验。与画布这个最外层的容器不同，组合体容器的开发必须考虑到其内部与外部的交互，以及多个组合体容器内部的交互。尽管为组合体对象提供的功能并不多，但都必须要考虑到对其内部包含的组件元素的影响，这也要求开发者在需求分析时得到更加完善的功能需求。

## 响应式内容块

通过响应式点击显示在磁贴周围的内容块，承担不便于在磁贴内部展示的详细内容。响应式内容块即可以是关于磁贴的拓展信息承载，也可以作为一个富文本编辑器的显示窗口。搭配提供的磁贴内容功能，能够便利地显示各类内容。

在普通思维导图的基础上加入显示磁贴内容的内容块是为了在提高信息密度的前提下，优化原有的思维导图的显示冗杂的问题。在此基础上，为了便于用于用户使用，还增添了许多内容块的响应式显示设置，包括全局显示控制，显示位置和显示状态的设置等。



