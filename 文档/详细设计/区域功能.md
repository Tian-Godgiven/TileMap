[toc]

# 顶部功能区

部分重要功能的实现如下：

（1）打开最近使用的文件：每当用户从本地打开工程文件时，将文件路径按顺序保存到软件日志文件中，最多保存10条，较旧的日志记录会被覆盖。

日志文件对一款应用程序来说至关重要，在本软件中，日志文件包括读取文件日志，错误日志与登录日志，分别保存为用户最近打开的工程文件信息，应用程序掷出的报错信息与软件登录请求的日志信息。后两者起到的主要作用为在应用程序出现运行故障、需要进行故障回溯时为我提供相应的信息。

（2）文件另存为：用户可以选择将工程文件另存为png图片和html文件格式。其中图片格式，通过htmltocanvas库提供的html2canvas方法实现预览和生成。Html格式文件的生成请参见下方代码文件嵌套功能的实现。用户可以在该界面中指定画布生成为图片，选择多张画布时将按顺序生成对应的多张图片，若为嵌套画布，则会在文件名中标注其嵌套源。若为png图片格式，用户可以查看对应的png图片的尺寸和文件大小。

（3）导出文件：点击后将弹出导出文件界面，能够将选择当前工程文件中的指定画布或应用程序内的集合导出为文件。这些文件都可以被重新导入软件中并保留原有的内容和功能。提供内容的导入和导出功能有助于用户更加便捷地在不同设备上使用或分享指定的内容。

（4）撤销与重做：用户在对某元素进行操作后，将会在撤销栈中记录该元素修改前的状态。通过撤销操作可以按栈顺序将该元素的状态修改回来，同时在重做栈中记录撤销前的状态。通过重做操作，可以按栈顺序将该元素的状态恢复到撤销前的状态。
	该功能的实现采用记录对象修改前的状态的方法，而非同类型软件中较为常见的记录画布状态的方法。这是为了更便捷地实现在线房间中多人操作下的撤销与重做，即撤销栈和重做栈只会记录和执行当前用户对其占有的画布对象进行的操作，而不会影响到其他用户的操作。使用undo和redo两个堆栈而非链式表的结构，也是因为在链式表结构在处理单个对象的状态信息时表现不佳，尤其是在切换保存对象时会出现数据重叠的问题。

（5）保存状态提示：若用户在操作工程文件后未进行保存或自动保存，则此处会标红提示用户进行保存操作，在该状态下点击此处即可进行保存。这个保存提示基于操作是否会进入撤销栈，也就是说非画布内容的修改操作均不会触发保存状态提示。

 （6）搜索：用户在点击搜索按键后会弹出搜索框，输入内容并进行搜索后，会显示搜索结果，其中会显示标题或内容符合搜索内容的画布，磁贴或内容块的缩略图，点击这些缩略图可以跳转到对应的画布，并将这个对象聚焦，显示在画布区中央。

搜索结果提供的是满足搜索条件的对象的跳转选项，在多层嵌套的画布结构中，让用户明确其当前所在的画布和即将移动到的画布是非常重要的。将磁贴标题和磁贴内容分开来作为搜索结果，也是因为用户需要知道其跳转目标的具体性质。嵌套树的格式能够直观地让用户感受到操作将会产生的结果，并将操作的控制权掌握在手中。

（7）登录与注册：用户在未登录账户的状态下，点击用户头像将弹出登录与注册菜单。若在登陆状态下，则可通过弹出选项进入个人主页，使用在线服务。

Web应用程序的前后端接口暴露，在没有对应插件的控制支持时，是非常严重的问题。别有用心的用户能通过暴露的接口对后端服务器造成恶劣的影响。

在本软件中，用户的登录信息会保存在electron主进程中，其与前端完全隔绝，只能通过封装好ipc通信相互传递数据。而除了登录、注册和找回密码以外，所有的后端通信都要求对这个登录信息进行验证，从而避免了通过暴露的接口与后端通信的可能性。至于这三个没有进行也无法进行登录情况验证的后端通信服务，则使用了限制登录频率和限制验证码的发送频率的方式进行了一定程度的保护。

# 对象交互区

即软件中的左侧部分

其中部分重要功能的实现如下：

（1）快捷使用菜单：用户可以将自定义磁贴保存到快捷使用菜单中，并对其中的磁贴进行管理。快捷使用菜单中的内容会在程序关闭后导出为菜单文件，并在下一次程序启动时读取该文件。快捷使用菜单不能删除，但可以清空其中的内容。用户可以将其中的内容导出为独立的文件，并在版本支持的软件中导入该文件以继续使用其中的内容。

在思维导图的制作过程中，相对固定的元素结构尤为重要。应用程提供的固定的磁贴结构无论如何都不应该也不能取代用户自定义的个性化结构，因此提供给用户一个保存其自定义的磁贴结构，并提供对应的管理功能，能够带给用户更加良好的使用体验。

（2）自定义磁贴集合：除了软件本身提供的磁贴集合以外，用户还能创建自定义的磁贴菜单。其功能与快捷使用菜单一致，但用户可以将其上传到注册账户并下载使用，并且用户可以选择删除自定义的磁贴菜单。

自定义磁贴集合为用户的个性化设计的重用提供了支持，通过导入、导出、上传和下载等方法，用户可以便捷地管理其需要经常使用的磁贴和模板对象。也能在用户之间分享和传递优秀的磁贴设置或模板。

# 修饰与内容区

包括：画布修饰区，画布内容区，磁贴修饰区，磁贴内容区的界面与功能

## 画布的修饰与内容区

（1）画布的网格背景：为指定的画布添加上一个可自定义密度和颜色的网格背景，用于辅助用户控制画布内对象的位置和尺寸等。这个网格背景通过svg元素实现。

​	由于画布本身支持300%的放大缩放，使用高分辨率的网格图片作为画布背景以满足在最大尺寸下对清晰度的需求，会导致该图片文件的大小过大，影响文件读取效率。此外，用户对网格背景的设置例如网格密度，颜色的设置也十分繁琐。
​	svg图片基于矢量描述，不依赖于特定的像素密度或分辨率，无论放大还是缩小都能保持清晰度，并且可以通过代码设置图片内容的各类规格与循环显示，在高清晰度的要求下，文件大小远小于位图格式文件。
​	不过，直接使用svg图片文件导入背景时，对网格背景的设置修改便会涉及到反复修改读取文件，使得文件存取安全性大幅下降。
​	为解决该问题，通过函数来生成符合要求的svg图片代码，再将这个代码转化为base64码，通过backgroud-image属性的url对base64的读取功能，在画布上覆盖一层定制化的网格背景，该网格背景的清晰度不受缩放影响。

（2）拷贝画布：拷贝画布将生成一张拥有新id的原画布的深拷贝画布对象，并为其重新分配新的画布id。这是因为在为磁贴嵌套画布时，实际为其绑定的是画布对象的id，在进入嵌套时，通过查找对应的画布id获得嵌套的画布对象。在应用程序中使用的对象id均为15位的随机大小写英文字母和数字的组合，还通过对象类型进行区分，因此意外产生两个相同id的同类型对象的概率低至可以忽略不计。

​	此外，在该过程中，用户可以选择是否拷贝原画布中的画布内对象。若用户选择了该选项，在拷贝过程中，也会为这些画布内对象分配新的随机id，还能够将原画布内对象设定的data数据拷贝到复制对象中。

（3）画布内容：当聚焦到画布上时，会在画布内容区以缩略图的形式显示该画布中的成员元素。如果其中的某个磁贴嵌套着一张画布，则该磁贴的缩略图下一行还会显示这个画布的缩略图，此时点击这个缩略图，还会在下一行显示这个嵌套画布中的成员元素。最终形成类似文件树的结构，用户可以点击缩略图，亦或是双击缩略图所在的行，移动到该对象所在的画布中，并令其聚焦，显示在画布区中心。

画布内容的显示方式类似于文件管理系统，为用户提供一目了然的画布结构信息。为了减少在大量内容的画布切换过程中产生冗余加载，只有在用户主动展开画布内容中的次级结构时，才会对其中的内容进行加载。

## 磁贴的修饰与内容区

（1）为磁贴嵌套画布：在嵌套画布菜单中，用户有三种方式选择画布并嵌套在磁贴中：

创建新画布会在确认后弹出画布创建窗口，并在正确创建新画布后，通过promise回调画布对象，将其嵌套给磁贴。

导入画布文件会在确认后弹出文件选择窗口，用户在选择工程文件后，从该工程文件包含的画布中选择一张，在当前工程文件中导入该画布的内容后，将其嵌套给磁贴。

选择已打开的画布选项令用户可以在当前工程文件中的画布中选择一张画布，令其嵌套给磁贴。这意味着一张画布可以同时嵌套给多个对象。

为用户提供多种嵌套选项能够减少用户的操作量，在本软件中，嵌套画布是一个常用且有特征性的功能，对该功能的使用提供多种适配能够给用户带来更好的使用体验。

（2）磁贴内容区：其本质上是一个HTML富文本编辑器，借由TinyMCE插件实现，编辑内容保存在对应的磁贴对象中。当对磁贴的内容进行修饰时，可以在内容区通过鼠标拖选一部分内容，令修饰功能只作用于这些内容。检测用户的鼠标在该区域内的行为，当鼠标松开时，检测是否有选中的文本，若存在则将这部分文本传入选中对象，否则选中对象将默认为整个文本。

修饰功能的本质是通过execCommand命令修改选中对象的样式，这些命令会使得选中的文本对象成为一段<div>代码，并设置不同的CSS属性，从而达成样式修改的效果。

​	TinyMCE在诸多富文本编辑器类插件中也是表现突出的一款插件，其开放的大量接口和方法大幅简化了原本的execCommand命令的操作流程，提供的自定义插件功能导入能够最大限度地给予开发者定制功能的权限。开发者在使用插件的过程中能充分发挥主观能动性，不会反过来受到插件的限制而不得不更改原本的设计。

（3）向磁贴内容插入磁贴或画布：通过设置TinyMCE的自定义插件，实现了可以在磁贴内容中选择插入磁贴对象，画布对象或内容块对象。在选择界面显示当前工程文件中的所有画布对象和磁贴对象，从中选择磁贴或画布，即可插入到内容区中光标所在的位置，形成一个缩略图，点击这个缩略图对象，即可跳转到对应的画布中，将对象显示在画布区中心。

​	该功能是对画布内容功能的进一步拓展，将磁贴和画布元素嵌套在磁贴内容中，能够起到导航和跳转引导的作用。与主流的思维导图设计软件不同，本软件中的磁贴元素能够以磁贴内容的形式包含大量的信息而不影响到整体思维导图的外观，并且画布之间形成的复杂嵌套结构会在一定程度上干扰用户的判断。为减少这种影响，需要为用户提供充足的引导和指示功能。

（4）编辑磁贴内容中的HTML代码：在磁贴内容区中输入的内容会被统一识别为字符串，即使其中存在HTML代码。不过，基于JavaScript的渲染机制，内容区内部是可以执行HTML代码的。通过HTML输入界面所输入的内容便会被识别为HTML对象，其将插入内容区光标所在的位置并执行。

​	该功能的服务对象为有HTML编码能力，并且对自定义内容有需求的用户。软件整体采用的就是HTML渲染，在一定程度上为用户提供此类编码服务能够拓宽用户的个性化定制范围，充分利用软件基层的优势。

# 画布区

其中部分重要功能的实现如下：

（1）插入表格：由于结构限制，向画布中插入表格时，并不会直接生成一个表格形态的磁贴对象，而是生成一个磁贴对象作为表标题，在这个磁贴对象下方持续显示一个有着表格内容的内容块。

​	由于底层代码对磁贴元素结构的限制，在读取JSON内容生成磁贴元素的过程中，其中的表格对象无法复现，因此并不能直接在磁贴元素上实现表格功能。不过TinyMCE的丰富插件库中，提供了便捷而高效的表格生成功能。转换一下思路，既然磁贴内容元素是对磁贴元素信息的拓充，那么将磁贴元素视作表标题，磁贴内容元素视作表本身，便能够得到一张功能完善的响应式显示的表格。当然，这种折中的做法虽然减少了开发难度，但也必然会将压力转移，使得用户的操作变得繁琐，仍然有待改进。

（2）画布区宽度移动栏：鼠标移入画布区两侧时，若该侧和修饰与内容区或对象交互区相邻，则会显示一条透明的宽度移动栏，鼠标点击并拖拽该宽度移动栏，可以随鼠标移动修改画布区与邻接区的宽度。然而，由于该移动栏宽度有限，当拖拽速度过快时，会导致鼠标在渲染完成之前就移出区域，因此常规的元素绑定鼠标事件方法无法完成本功能。因此，在元素绑定鼠标事件中，增加一个页面全局的鼠标事件监听，通过变量控制全局监听的触发，从而解决鼠标移动速度过快导致的渲染与事件产生时间差的问题。

​	JavaScript的单进程循环事务的性质在诸多领域广受好评，其中事件监听功能为开发者定制个性化的应用程序功能提供大量帮助。但是实际运行过程中，用户的操作往往不会与开发者预想的操作完全符合，从而出现非期望的结果。对于开发者而言，通过限制的方式规制用户的违规操作是一种简单且高效的做法，但也应当注意到开发者构思过程存在的不完善是否会影响到用户的使用体验。在本案例中我们将原本简单的hover方法改写为了多个冗余的事件监听，这种做法从代码设计的角度来说不敢恭维，但却实际提高了用户的操作体验，使得用户的拖拽操作更加自由，无需控制鼠标在窄小的控制栏内缓慢移动。有时候开发者应当注意到，独断地掌控软件的使用方法，是变相地对用户需求的忽视，这势必会造成需求与实现的割裂。

## 个人主页

其中部分重要功能的实现如下：

（1）上传文件：在个人主页界面，会显示该账户上传到服务器的自定义磁贴或模板文件，和保存在云端的工程文件。用户在进入个人页面时，客户端会向服务器发送http请求，以获取对应账户上传的文件信息，服务器在响应这个请求时，会将数据库中保存的上传文件的信息返回客户端，以供用户进一步的操作如下载、删除、上传。

​	为了便于开发测试，也为了提供给用户更多的控制权限，本软件将开发者工具的调用嵌套在前端页面中。一部分恶意用户能够使用其中的命令行工具，通过前端暴露的接口对服务端产生影响。因此，如前文中提到的一样，所有向后端的请求都被封装在一个与前端渲染进程隔离的主进程文件中，并且所有请求都会对当前的用户登录状态进行验证。

（2）头像修改：用户在选择头像上传时，会对图片类型、大小进行判定，确认合适后才会弹出头像裁剪菜单，使用Cropper.js插件提供的方法对上传图片进行裁剪，并将裁剪完成后的图片作为头像上传到服务器。

​	cropper插件的工作原理是在指定的img元素上生成一个不透明的蒙版，将可移动的裁剪框dom覆盖在蒙版上，从而实现了图片的裁剪功能。在用户选择保存头像时，插件的getCroppedCanvas()方法将这个裁剪框dom包含的内容转化为canvas对象，为了将其保存在文件中，进一步使用toDataURL()方法将其转化为base64图片数据，并上传至服务器中保存。